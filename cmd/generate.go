package cmd

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"sort"
	"strings"
)

func RunGenerate(modelName string, pbFile string, importPath string) {
	// 假设固定路径（或后续用 flag 参数）
	// const pbFile = "errorx/errorcode/error.pb.go"

	const (
		outFile  = "./errors_gen.go"
		wrapFile = "./wrap.go"
	)
	generateWrapFile(wrapFile, modelName, importPath)
	fmt.Println("✅ 生成完成:  - 包装逻辑:", wrapFile)
	enumMap := make(map[int]string)
	entryRe := regexp.MustCompile(`\s*(\d+):\s*"([^"]+)"`)

	file, err := os.Open(pbFile)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		match := entryRe.FindStringSubmatch(line)
		if len(match) == 3 {
			code := match[1]
			name := match[2]
			enumMap[toInt(code)] = name
		}
	}

	// 排序输出
	keys := make([]int, 0, len(enumMap))
	for k := range enumMap {
		keys = append(keys, k)
	}
	sort.Ints(keys)

	// 写入 go 文件
	f, err := os.Create(outFile)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	fmt.Fprintf(f, "// Code generated by generrorx; DO NOT EDIT.\n\n")
	fmt.Fprintf(f, "package %s\n\n", modelName)
	fmt.Fprintf(f, "import errorcode \"%s\"\n\n", importPath)

	for _, code := range keys {
		enumName := enumMap[code]
		varName := toExportedName(enumName)
		fullEnum := "errorcode.ErrorCode_" + enumName
		fmt.Fprintf(f, "var %s = NewErrorFromCodeAutoMsg(%s)\n", varName, fullEnum)
	}

	fmt.Println("✅ 错误变量已生成:", outFile, "模型:", modelName)
}

func toExportedName(name string) string {
	parts := regexp.MustCompile("_").Split(name, -1)
	for i, p := range parts {
		parts[i] = strings.Title(strings.ToLower(p))
	}
	return "Err" + strings.Join(parts, "")
}

func toInt(s string) int {
	var i int
	fmt.Sscanf(s, "%d", &i)
	return i
}
func generateWrapFile(outFile string, modelName string, importPath string) {
	f, err := os.Create(outFile)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	fmt.Fprintf(f, `// Code generated by generrorx; DO NOT EDIT.

package %s

import (
	"encoding/json"
	errorcode "%s"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)
type CustomError struct {
	Code    int    // 错误码
	Message string // 错误消息
}
func (e *CustomError) ToGrpcError() error {
	var grpcCode codes.Code
	grpcCode = codes.Unknown

	// 将 Details 序列化为 JSON 字符串
	return status.Errorf(grpcCode, "code: %%d, message: %%s, details: %%s", e.Code, e.Message, "")
}

func (e *CustomError) ToHttpError() []byte {
	resp := map[string]interface{}{
		"code":    e.Code,
		"message": e.Message,
	}

	data, err := json.Marshal(resp)
	if err != nil {
		// 出现序列化错误，返回简化错误信息
		fallback := map[string]interface{}{
			"code":    500,
			"message": "internal server error",
		}
		fallbackData, _ := json.Marshal(fallback)
		return fallbackData
	}
	return data
}

func NewError(code int, message string) *CustomError {
	return &CustomError{
		Code:    code,
		Message: message,
	}
}

func NewErrorFromCodeAutoMsg(code errorcode.ErrorCode) *CustomError {
	return NewError(int(code), code.String()) // 自动用枚举名作为 message
}

`, modelName, importPath)
}
