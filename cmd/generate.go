package cmd

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"sort"
	"strings"
)

func RunGenerate(modelName string, pbFile string, importPath string) {
	// 假设固定路径（或后续用 flag 参数）
	// const pbFile = "errorx/errorcode/error.pb.go"

	const (
		outFile  = "./errors_gen.go"
		wrapFile = "./wrap.go"
	)
	generateWrapFile(wrapFile, modelName, importPath)
	fmt.Println("✅ 生成完成:  - 包装逻辑:", wrapFile)
	enumMap := make(map[int]string)
	entryRe := regexp.MustCompile(`\s*(\d+):\s*"([^"]+)"`)

	file, err := os.Open(pbFile)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		match := entryRe.FindStringSubmatch(line)
		if len(match) == 3 {
			code := match[1]
			name := match[2]
			enumMap[toInt(code)] = name
		}
	}

	// 排序输出
	keys := make([]int, 0, len(enumMap))
	for k := range enumMap {
		keys = append(keys, k)
	}
	sort.Ints(keys)

	// 写入 go 文件
	f, err := os.Create(outFile)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	fmt.Fprintf(f, "// Code generated by generrorx; DO NOT EDIT.\n\n")
	fmt.Fprintf(f, "package %s\n\n", modelName)
	fmt.Fprintf(f, "import errorcode \"%s\"\n\n", importPath)

	for _, code := range keys {
		enumName := enumMap[code]
		varName := toExportedNameCamel(enumName)
		fullEnum := "errorcode.ErrorCode_" + enumName
		fmt.Fprintf(f, "var %s = NewErrorFromCodeAutoMsg(%s)\n", varName, fullEnum)
	}

	fmt.Println("✅ 错误变量已生成:", outFile, "模型:", modelName)
}

func splitCamelCase(s string) []string {
	var result []string
	var last int
	for i := 1; i < len(s); i++ {
		if isUpper := 'A' <= s[i] && s[i] <= 'Z'; isUpper {
			result = append(result, s[last:i])
			last = i
		}
	}
	result = append(result, s[last:])
	return result
}

func toExportedNameCamel(s string) string {
	parts := splitCamelCase(s)
	for i, p := range parts {
		parts[i] = strings.Title(strings.ToLower(p))
	}
	return "Err" + strings.Join(parts, "")
}

func toInt(s string) int {
	var i int
	fmt.Sscanf(s, "%d", &i)
	return i
}
func generateWrapFile(outFile string, modelName string, importPath string) {
	f, err := os.Create(outFile)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	fmt.Fprintf(f, `// Code generated by generrorx; DO NOT EDIT.

package %s

import (
	"encoding/json"
	errorcode "%s"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)
type Error struct {
	Code    int    // 错误码
	Message string // 错误消息
}

func (err *Error) Error() string {
	if err == nil {
		return ""
	}

	errStr := err.text

	// 如果 text 为空但是有 code，就用 code 的 message
	if errStr == "" && err.code != nil {
		errStr = err.code.Message()
	}

	// 如果内部还有嵌套 error，就拼接上去
	if err.error != nil {
		if errStr != "" {
			errStr += ": "
		}
		errStr += err.error.Error()
	}

	return errStr
}


func NewError(code int, message string) *Error {
	return &Error{
		Code:    code,
		Message: message,
	}
}

func NewErrorFromCodeAutoMsg(code errorcode.ErrorCode) *Error {
	return NewError(int(code), code.String()) // 自动用枚举名作为 message
}

`, modelName, importPath)
}
