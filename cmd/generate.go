package cmd

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"sort"
	"strings"
)

func RunGenerate(modelName string, pbFile string, importPath string) {
	const (
		outFile  = "./errors_gen.go"
		wrapFile = "./wrap.go"
	)
	generateWrapFile(wrapFile, modelName, importPath)
	fmt.Println("✅ 生成完成:  - 包装逻辑:", wrapFile)

	// 读取枚举
	enumMap := make(map[int]string)
	entryRe := regexp.MustCompile(`\s*(\d+):\s*"([^"]+)"`)

	file, err := os.Open(pbFile)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		match := entryRe.FindStringSubmatch(line)
		if len(match) == 3 {
			code := match[1]
			name := match[2]
			enumMap[toInt(code)] = name
		}
	}

	// 排序输出
	keys := make([]int, 0, len(enumMap))
	for k := range enumMap {
		keys = append(keys, k)
	}
	sort.Ints(keys)

	// 先解析旧文件里的 keep 标记
	keepMap := parseKeepVars(outFile)

	// 写入 go 文件
	f, err := os.Create(outFile)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	fmt.Fprintf(f, "// Code generated by generrorx; DO NOT EDIT.\n\n")
	fmt.Fprintf(f, "package %s\n\n", modelName)
	fmt.Fprintf(f, "import errorcode \"%s\"\n\n", importPath)

	for _, code := range keys {
		enumName := enumMap[code]
		varName := toExportedNameCamel(enumName)
		fullEnum := "errorcode.ErrorCode_" + enumName

		// 如果用户在旧文件标记了 keep，则保留原行
		if line, ok := keepMap[varName]; ok {
			fmt.Fprintln(f, line)
		} else {
			fmt.Fprintf(f, "var %s = NewErrorFromCodeAutoMsg(%s)\n", varName, fullEnum)
		}
	}

	fmt.Println("✅ 错误变量已生成:", outFile, "模型:", modelName)
}

// ----------------- 新增方法 -----------------

// parseKeepVars 解析旧文件中带有 `// +generrorx:keep` 的变量行
func parseKeepVars(file string) map[string]string {
	result := make(map[string]string)

	data, err := os.ReadFile(file)
	if err != nil {
		return result // 文件不存在时直接返回空
	}
	lines := strings.Split(string(data), "\n")

	// 匹配形如：var ErrXXX = ...
	re := regexp.MustCompile(`var\s+(\w+)\s+=`)

	for i := 0; i < len(lines); i++ {
		line := lines[i]
		if strings.Contains(line, "// +generrorx:keep") {
			// 下一行应该是变量声明
			if i+1 < len(lines) {
				next := lines[i+1]
				m := re.FindStringSubmatch(next)
				if len(m) == 2 {
					varName := m[1]
					// 保留注释 + 变量行
					result[varName] = line + "\n" + next
				}
			}
		}
	}
	return result
}

// ----------------- 你原来的工具方法 -----------------

func splitCamelCase(s string) []string {
	var result []string
	var last int
	for i := 1; i < len(s); i++ {
		if isUpper := 'A' <= s[i] && s[i] <= 'Z'; isUpper {
			result = append(result, s[last:i])
			last = i
		}
	}
	result = append(result, s[last:])
	return result
}

func toExportedNameCamel(s string) string {
	parts := splitCamelCase(s)
	for i, p := range parts {
		parts[i] = strings.Title(strings.ToLower(p))
	}
	return "Err" + strings.Join(parts, "")
}

func toInt(s string) int {
	var i int
	fmt.Sscanf(s, "%d", &i)
	return i
}

func generateWrapFile(outFile string, modelName string, importPath string) {
	f, err := os.Create(outFile)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	fmt.Fprintf(f, `// Code generated by generrorx; DO NOT EDIT.

package %s

import (
	"encoding/json"
	errorcode "%s"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)
type Error struct {
	Code    int    // 错误码
	Message string // 错误消息
}

func (err *Error) Error() string {
	if err == nil {
		return ""
	}

	errStr := err.text

	// 如果 text 为空但是有 code，就用 code 的 message
	if errStr == "" && err.code != nil {
		errStr = err.code.Message()
	}

	// 如果内部还有嵌套 error，就拼接上去
	if err.error != nil {
		if errStr != "" {
			errStr += ": "
		}
		errStr += err.error.Error()
	}

	return errStr
}


func NewError(code int, message string) *Error {
	return &Error{
		Code:    code,
		Message: message,
	}
}

func NewErrorFromCodeAutoMsg(code errorcode.ErrorCode) *Error {
	return NewError(int(code), code.String()) // 自动用枚举名作为 message
}

`, modelName, importPath)
}
